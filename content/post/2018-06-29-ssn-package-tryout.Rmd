---
title: SSN package tryout
author: Ty Tuff
date: '2018-06-29'
slug: ssn-package-tryout
categories:
  - R packages
tags:
  - SSN
  - R packages
---

Load SSN package.
```{r message=FALSE}
require(SSN)
```

### Simulate stream network
First we simulate 2 stream networks in the format which the SSN package expects to be given from STARS. We follow this by plotting the 2 networks with sampling sites depicted as black hollow circles and prediction sites as green filled circles.

```{r}
my.ssn <- createSSN(n = c(10, 10),
          obsDesign = hardCoreDesign(c(200, 200), c(0.2, 0.4)),
          predDesign = systematicDesign(c(0.3, 0.6)),
          importToR = TRUE,
          path = paste(getwd(), "/ssnprac.ssn", sep = ""),
          treeFunction = iterativeTreeLayout)
plot(my.ssn, lwdLineCol = "addfunccol", lwdLineEx = 10, lineCol = "blue", cex = 2, pch = 1, xlab = "x-coord", ylab = "y-coord")
plot(my.ssn, PredPointsID = "preds", add = TRUE, pch = 16, col = "green")
```


The obsDesign and predDesign arguments are both functions which specify the way in which sampling and prediction sites are spread out in the network. These are:  
1.  binomialDesign(n) - uniformally and randomly distributes n points on the network
2.  poissonDesign(lambda) - generates points on the network at a rate lambda
3.  systematicDesign(spacing) - generates points that are at a constant distance away from each other
4.  hardCoreDesign(n, inhibition_region) - generates points randomly and then eliminates them until they are are at least inhibition region away from each other
There are 2 ways in which the stream network can be simulated:
1.  igraphKamadaKawai   -  works faster but creates more unrealistic networks
2.  iterativeTreeLayout - takes longer but makes more realistic networks
Plot the strean network with sampling sites as black circles and prediction locations as green dots
### Generate stream network data
First, we need to create the distance matrix calculating hydrological distance between sites

```{r}
createDistMat(my.ssn, "preds", o.write = TRUE, amongpreds = TRUE)
```


Second, we need to extract the observation and prediction dataframes and fill them with some dummy data.
```{r}
# Exract dataframes
raw.obs <- getSSNdata.frame(my.ssn, "Obs")
raw.pred <- getSSNdata.frame(my.ssn, "preds")
# Fill dataframes
raw.obs$cont1 <- rnorm(length(raw.obs[,1]))
raw.pred$cont1 <- rnorm(length(raw.pred[,1]))
raw.obs$cont2 <- rnorm(length(raw.obs[,1]))
raw.pred$cont2 <- rnorm(length(raw.pred[,1]))
raw.obs$factor1 <- as.factor(sample.int(4, length(raw.obs[,1]), replace = TRUE))
raw.pred$factor1 <- as.factor(sample.int(4, length(raw.pred[,1]), replace = TRUE))
raw.obs$random1 <- as.factor(sample(1:3, length(raw.obs[,1]), replace = TRUE))
raw.obs$random2 <- as.factor(sample(1:4, length(raw.obs[,1]), replace = TRUE))
raw.pred$random1 <- as.factor(sample(1:3, length(raw.pred[,1]), replace = TRUE))
raw.pred$random2 <- as.factor(sample(1:4, length(raw.pred[,1]), replace = TRUE))
```

Third, the modified dataframes with the stream network data needs to be redistributed on the network with the spatial autocorrelated errors from the Ver Hoef and Peterson tail-up/tail-down models.
```{r}
sim.out <- SimulateOnSSN(my.ssn, ObsSimDF = raw.obs, PredSimDF = raw.pred, "preds", formula = ~ cont1 + cont2 + factor1, coefficients = c(10, 1, 0, -2, 0, 2), CorModels = c("LinearSill.tailup", "Mariah.taildown", "Exponential.Euclid", "random1", "random2"), use.nugget = TRUE, CorParms = c(3, 10, 2, 10, 1, 5, 1, 0.5, 0.1), addfunccol = "addfunccol")
```


We can check to see that the coefficients and correlation models we supplied were implemented correctly
```{r}
sim.out$FixedEffects
sim.out$CorParms
```


Finally, we can extract and visualize the stream network with the data represented by coloured circles.
```{r}
sim.ssn <- sim.out$ssn.object
plot(sim.ssn, "Sim_Values", xlab = "x-coord", ylab = "y-coord", cex = 1.5)
```

### Modelling stream data
To model the stream, we will use the prediction sites and attempt to predict the values at those locations which we generated in the previous section.
We have to extract the dataframes again so that we can store the correct values from the prediction sites and compare them against the ones generated by the model we use later on.
```{r}
sim.obs <- getSSNdata.frame(sim.ssn, "Obs")
sim.pred <- getSSNdata.frame(sim.ssn, "preds")
stored.preds <- sim.pred$Sim_Values
sim.pred$Sim_Values <- NA
sim.ssn <- putSSNdata.frame(sim.pred, sim.ssn, "preds")
```

Next we will fit a model to our data and check out the output.
```{r}
glmssn.out <- glmssn(Sim_Values ~ cont1 + cont2 + factor1, sim.ssn, CorModels = c("LinearSill.tailup", "Mariah.taildown", "Exponential.Euclid", "random1", "random2"), addfunccol = "addfunccol")
summary(glmssn.out)
```



Finally, to assess how well our model performed we will plot the real values against the values predicted by the model.
```{r}
glmssn.pred <- predict(glmssn.out, "preds")
predictions <- getSSNdata.frame(glmssn.pred, "preds")
plot(stored.preds, predictions$Sim_Values, xlab = "True", ylab = "Predicted", pch = 19)
```








